<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Async Rust and TUI</title>

    <meta name="description" content="Async Rust and TUI" />
    <meta name="author" content="Cyril Marin, Ren√© Ribaud" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />

    <link rel="stylesheet" href="../reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="../reveal.js/dist/theme/beige.css" />
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia"> -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Satisfy"> -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet"> -->

    <!-- Code syntax highlighting -->
    <!-- <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" /> -->
    <link rel="stylesheet" href="css/stackoverflow-light.css" />

    <style type="text/css">
      .iwantitatleft {
        text-align: left;
      }

      .longtext {
        text-align: left;
        font-size: 0.6em;
      }

      /* Larger elements */
      .lots_of_items2 ul {
        font-size: 0.7em;
        text-align: left;
      }

      /* Smaller elements */
      .lots_of_items3 ul {
        font-size: 0.55em;
        text-align: left;
      }

      .lots_of_items3 ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items3 table {
        font-size: 0.8em;
        float: left;
        margin-right: 1em;
      }

      /* Larger elements */
      .lots_of_items4 ul {
        font-size: 0.8em;
        text-align: left;
      }

      /* Normal elements */
      .lots_of_items ul {
        font-size: 0.6em;
        text-align: left;
      }

      .lots_of_items ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items h3 {
        font-size: 0.7em;
      }

      .lots_of_items h4 {
        font-size: 0.6em;
      }

      .lots_of_items code {
        font-size: 0.7em;
      }

      .lots_of_items table {
        float: left;
        margin-right: 1em;
      }

      .clearfix {
        clear: left;
      }

      .long_link a {
        font-size: 0.8em;
      }

      .pic {
        position: relative;
        float: left;
        width: 50%;
        top: 0px;
      }

      /* Remove image margin use in conjuction with .pic */
      .no_margin img {
        margin: 0px;
      }

      .left_text {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
      }

      .left_text_top_margin {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
        margin-top: 66px;
      }

      .left_text_bio {
        position: relative;
        float: left;
        width: 50%;
        font-size: 0.6em;
        text-align: left;
      }

      .right_text {
        width: 50%;
        text-align: left;
        float: right;
        text-align: left;
      }

      .skill-list li {
        font-size: 1.5rem;
        margin-top: 1rem;
      }
      /*
            .reveal a { color: #007DBA; }
            .reveal h2 b { color: #0096D6; }
            .reveal h2 .day { font-size: 0.6em; position:relative; bottom: 20px; }
            .reveal { font-family: "Source Code Pro", "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,sans-serif; font-size:40px; }
            */
      .reveal {
        font-family:
          "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
        font-size: 40px;
      }

      .reveal h2 {
        margin-top: 35px;
      }

      .reveal ul {
        margin: 0 0 0 0;
      }

      .reveal pre {
        width: 100%;
        font-size: 18px;
      }

      .reveal pre code {
        max-height: 100%;
      }

      .reveal section img {
        border: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0);
      }

      body {
        line-height: 1.1;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- <section data-background="images/background.svg" data-background-size="cover"> -->
        <section>
          <h1>Async Rust and TUI</h1>
          <img src="images/snowcamp_logo.png" alt="snowcamp_logo" width="25%" />

          <h2>Snowcamp 2026</h2>
        </section>

        <section
          data-background="images/snowcamp_sponsors.png"
          data-background-size="cover"
        ></section>

        <section>
          <h3>Async Rust and TUI</h3>
          <h4>Welcome and Development Environment Setup</h4>
          <div class="lots_of_items4">
            <ul>
              <li>
                Save time by doing the setup if not already done or as an
                alternative use
                <a href="https://github.com/codespaces"
                  >https://github.com/codespaces</a
                >.
              </li>
              <ol>
                <li>
                  <strong>Install Rust</strong>: rustup, rustc, cargo, clippy,
                  rustfmt.
                </li>
                <li>
                  <strong>Configure Editor</strong>: Set up your preferred
                  editor with Rust Analyzer.
                </li>
                <li>
                  <strong>Clone the workshop repository</strong>
                  from GitHub.<br />
                  <a href="https://github.com/uggla/async_rust_tui"
                    >https://github.com/uggla/async_rust_tui</a
                  >
                </li>
                <li>
                  Get your personal SNCF API key<br />
                  <a
                    href="https://numerique.sncf.com/startup/api/token-developpeur/"
                    >https://numerique.sncf.com/startup/api/token-developpeur/</a
                  >
                  <ul>
                    <li>
                      If you don‚Äôt want to create a personal API key for the
                      workshop, you can download a pre-generated one instead
                      (<em>workshop use only</em>).
                    </li>
                    <li>
                      Download link:
                      <code style="font-size: 0.7em">
                        http://&ltwe_will_give_the_ip&gt>:8000/SNCF_API_KEY
                      </code>
                    </li>
                  </ul>
                </li>
              </ol>
              <li>Then we will do the introduction.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>A few words about us 1/2</h3>
          <div class="left_text_bio">
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: Cyril</li>
                <li>Last name: Marin</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Cloud engineer</li>
                <li>Latest Guild: Mimosa</li>
                <li>Age of Experience: 10+ years</li>
                <li>Preferred weapons: YAML, Shell</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Lone wolf</li>
                <li>Ex-developer but still coder</li>
                <li>
                  The only tuxedo user among a whole team of half bitten apple
                  (Does that make me a rebel undercover?)
                </li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/cyril.png" alt="Cyril" width="53%" />
          </div>
        </section>

        <section>
          <h3>A few words about us 2/2</h3>
          <div class="left_text_bio">
            <!-- <pre class="bio"> -->
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: Ren√© (Uggla)</li>
                <li>Last name: Ribaud</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Software engineer</li>
                <li>Previous Class: Solution architect (Cloud / Devops)</li>
                <li>Latest Guild: Red Hat</li>
                <li>Game start: 1998</li>
                <li>Preferred weapons: Rust / Python</li>
                <li>Artefact: Openstack Nova</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Linux and FLOSS since 1995</li>
                <li>Previously Ops, Dev today to produce my bugs</li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/uggla.png" alt="Ren√©" width="53%" />
          </div>
        </section>

        <section>
          <h3>Disclaimer & quick poll</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                This session is labeled as <strong>intermediate</strong>.
                <ul>
                  <li>
                    If you missed it, no worries ‚Äî it happens quite often üôÇ
                  </li>
                </ul>
              </li>

              <li>
                To adapt the pace and the level of details, let‚Äôs do a quick
                poll:
                <ul>
                  <li>
                    What is your Rust experience?
                    <ul>
                      <li>new to Rust / beginner</li>
                      <li>some Rust experience</li>
                      <li>comfortable with Rust</li>
                    </ul>
                  </li>

                  <li>
                    What is your main background?
                    <ul>
                      <li>low-level (C / C++)</li>
                      <li>systems / backend (Rust, Go, Java, etc.)</li>
                      <li>high-level (Python, JavaScript, etc.)</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                Based on this:
                <ul>
                  <li>
                    we may go through some <strong>optional slides</strong>,
                  </li>
                  <li>or skip them if everyone is already comfortable.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Quick Overview of Rust (Optional)</h3>
          <ul>
            <li>
              Provide an alternative to C/C++ and also higher-level languages
            </li>
            <li>
              Multi paradigm language (imperative, functional, object oriented
              (not fully))
            </li>
            <li>Fast, safe, and efficient (modern)</li>
            <li>No garbage collector, ownership and borrow checker</li>
            <li>Dual license MIT and Apache v2.0</li>
            <li>First stable release May 15th, 2015</li>
          </ul>
        </section>

        <section>
          <h3>Common misconception (Optional)</h3>
          <h4>Rust has a hard learning curve</h4>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Yes</strong>: Rust offers many powerful features and
                concepts, which can make the language look difficult at first.
                However, you can write
                <strong>simple and idiomatic Rust</strong> without using
                everything, and learn the language
                <strong>step by step</strong>.
              </li>
              <li>
                But many frustrations come from a different root cause:
                <ul>
                  <li>
                    People <strong>don‚Äôt read the book</strong> (at least the
                    key chapters),
                  </li>
                  <li>
                    They try to
                    <strong>transpose habits from other languages</strong>, and
                    quickly hit Rust‚Äôs unique concepts (ownership/borrowing,
                    lifetimes, traits‚Ä¶).
                  </li>
                  <li>
                    Developers coming from <strong>C/C++</strong> sometimes feel
                    <strong>limited or constrained by the compiler</strong>.
                  </li>
                  <li>
                    People often
                    <strong>don‚Äôt read the compiler error messages</strong>,
                    even though they are usually precise and actionable.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Some of the main difficulties (Optional)</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>1) Immutability</strong></li>
              <ul>
                <li>
                  <strong>Immutable by default</strong> (you opt-in with
                  <code>mut</code>).
                </li>
                <li>
                  Immutable ‚â† constant:
                  <ul>
                    <li><strong>const</strong> / compile-time constants</li>
                    <li>
                      <strong>immutable bindings</strong> / runtime values that
                      simply cannot be modified
                    </li>
                  </ul>
                </li>
              </ul>

              <li><strong>2) Ownership</strong> (because there is no GC)</li>
              <ul>
                <li>
                  Goal: <strong>prevent memory errors</strong> (use-after-free,
                  double free, data races).
                </li>
                <li>
                  Core tool: <strong>borrowing</strong> (use references to avoid
                  moving ownership).
                </li>
              </ul>

              <li><strong>3) Type system</strong></li>
              <ul>
                <li>
                  An extremely strict system built on
                  <strong>strong typing</strong>.
                </li>
                <li>
                  It pushes you to make states explicit (enums), model
                  invariants, and handle errors properly.
                </li>
                <li>
                  <strong>No nulls</strong>: there is no <code>null</code>.
                  Instead, Rust encodes absence and errors in the type system:
                  <ul>
                    <li><code>Option&lt;T&gt;</code> for ‚Äúvalue or nothing‚Äù</li>
                    <li>
                      <code>Result&lt;T, E&gt;</code> for ‚Äúsuccess or error‚Äù
                    </li>
                  </ul>
                  This can feel <strong>confusing at first</strong>, but it
                  forces you to handle all cases explicitly.
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Quick Overview of the project</h3>
          <div class="left_text lots_of_items2">
            <ul>
              <li>
                Goals of the Workshop:
                <ul>
                  <li>
                    Structure a
                    <strong>small and near-realistic Rust project</strong>
                  </li>
                  <li>
                    Use key crates from the ecosystem:
                    <strong>Tokio</strong>, <strong>Reqwest</strong>,
                    <strong>Serde</strong>, <strong>Ratatui</strong>,
                    <strong>Anyhow</strong>, etc.
                  </li>
                  <li>Consume a real-time API (e.g. SNCF data)</li>
                  <li>
                    Handle asynchronism to refresh data
                    <strong>without blocking the UI</strong>
                  </li>
                  <li>
                    Showcase many <strong>Rust language features</strong>
                    (ownership, borrowing, async/await, traits, error handling,
                    etc.)
                  </li>
                </ul>
              </li>

              <li>
                What we will build together:
                <ul>
                  <li>
                    A TUI dashboard for train departures between two stations
                  </li>
                </ul>
              </li>
            </ul>
          </div>

          <div class="pic lots_of_items">
            <video width="100%" autoplay loop muted>
              <source src="images/async_rust_tui.mp4" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
        </section>

        <section>
          <h3>Quick overview of the session</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Each step starts with <strong>slides</strong>:
                <ul>
                  <li>explanation of the goal,</li>
                  <li>key concepts and points of attention.</li>
                  <li>
                    the full project is around
                    <strong>~2000 lines of code</strong>, which is not something
                    we can build from scratch during a workshop
                  </li>
                  <li>
                    this explains the approach: we progressively explore and
                    evolve an existing codebase
                  </li>
                </ul>
              </li>

              <li>
                Then we move to the code:
                <ul>
                  <li>we use <code>cargo t</code> to run the test suite,</li>
                  <li>
                    the goal is usually to <strong>fix the code</strong>, with
                    errors <strong>intentionally focused</strong> on the topic
                    of the current part
                  </li>
                  <li>
                    but fixing tests is <strong>not the main objective</strong>
                  </li>
                  <li>
                    the real goal is to:
                    <ul>
                      <li>understand the code,</li>
                      <li>identify patterns and design choices,</li>
                      <li>and ask questions when something is unclear.</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                We decide <strong>together</strong> how to proceed:
                <ul>
                  <li>we fix things live if needed,</li>
                  <li>or we move on if the audience feels comfortable.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- ========================== -->
        <!-- BLOC 1 : INTRO & STRUCTURE -->
        <!-- ========================== -->
        <section>
          <h3>Part 1 - Setup and tracing</h3>
          <img src="images/part01.jpg" alt="setup and tracing" width="72%" />
        </section>

        <section>
          <h3>Part 1 ‚Äî Setup your project correctly</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>Workspace-based project</strong></li>
              <ul>
                <li>
                  The project is organized as a
                  <strong>Cargo workspace</strong>.
                </li>
                <li>
                  It allows us to split responsibilities into multiple crates
                  and
                  <strong>improve compilation times</strong>.
                </li>
              </ul>

              <li><strong>API crate</strong></li>
              <ul>
                <li>
                  A dedicated crate is used to interact with the external API.
                </li>
                <li>
                  Benefits:
                  <ul>
                    <li>clear separation of concerns,</li>
                    <li>reusable logic,</li>
                    <li>faster rebuilds when working on the UI.</li>
                  </ul>
                </li>
              </ul>

              <li><strong>Crate boundaries</strong></li>
              <ul>
                <li><code>lib.rs</code> ‚Äî public API of a crate</li>
                <li><code>main.rs</code> ‚Äî binary entry point</li>
                <li>
                  The binary imports and uses the API crate like any external
                  dependency.
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 1 ‚Äî Setup your project correctly (cont.)</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>Visibility & API design</strong></li>
              <ul>
                <li>Items are <strong>private by default</strong>.</li>
                <li>
                  <code>pub</code> defines what is exposed outside the crate.
                </li>
                <li>
                  Crate boundaries act as a <strong>clear API contract</strong>.
                </li>
              </ul>

              <li><strong>Error handling strategy</strong></li>
              <ul>
                <li>
                  <code>thiserror</code> ‚Äî structured errors in
                  <strong>libraries</strong>
                </li>
                <li>
                  <code>anyhow</code> ‚Äî ergonomic error handling in
                  <strong>binaries</strong>
                </li>
                <li>
                  Rule of thumb:
                  <ul>
                    <li><strong>Libraries</strong>: typed, explicit errors</li>
                    <li>
                      <strong>Binaries</strong>: flexible error propagation
                    </li>
                  </ul>
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 1 ‚Äî Crates</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>dotenvy</strong></li>
              <ul>
                <li>
                  Loads environment variables from a <code>.env</code> file.
                </li>
                <li>
                  Useful to keep configuration outside the code (API keys,
                  endpoints, feature flags).
                </li>
              </ul>

              <li><strong>tracing</strong></li>
              <ul>
                <li>
                  The <strong>go-to crate</strong> to instrument Rust
                  applications.
                </li>
                <li>
                  Designed to measure and observe execution:
                  <ul>
                    <li>structured logs,</li>
                    <li>timings and latencies,</li>
                    <li><strong>spans</strong> to follow execution paths.</li>
                  </ul>
                </li>
                <li>
                  Can export data to <strong>OpenTelemetry</strong> for advanced
                  observability.
                </li>
                <li>
                  In this workshop:
                  <ul>
                    <li>
                      we rely on
                      <strong><code>log</code> compatibility</strong>,
                    </li>
                    <li>and write logs to a <strong>file</strong>,</li>
                    <li>
                      which is essential for debugging because
                      <strong
                        >stdout / stderr are not available in TUI mode</strong
                      >.
                    </li>
                  </ul>
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <!-- ======================= -->
        <!-- BLOC 2 : Async and mpsc -->
        <!-- ======================= -->
        <section>
          <h3>Part 2 - Async and mpsc</h3>
          <img src="images/part02.jpg" alt="async and mpsc" width="37%" />
        </section>

        <section>
          <h3>Part 2 ‚Äî Goals</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                We move to <strong>async</strong> early on:
                <ul>
                  <li>to avoid blocking the future TUI loop,</li>
                  <li>
                    to later perform
                    <strong>real API requests asynchronously</strong>,
                  </li>
                  <li>without changing the overall architecture.</li>
                </ul>
              </li>
              <li>
                For now, the <strong>TUI loop is simulated</strong> inside the
                <code>run()</code> function.
                <ul>
                  <li>
                    It represents the future event loop: rendering, input
                    handling, and state updates.
                  </li>
                </ul>
              </li>

              <li>
                A <strong>background task</strong> simulates periodic data
                updates:
                <ul>
                  <li>it acts like the SNCF API refresh,</li>
                  <li>sends new data at regular intervals,</li>
                  <li>communicates with the TUI loop via a channel.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 ‚Äî Async</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>You need an executor</strong> to run async code
                <ul>
                  <li>
                    <code>async fn</code> returns a <strong>Future</strong> (it
                    does not run by itself)
                  </li>
                  <li>
                    An executor is responsible for
                    <strong>polling</strong> futures and making progress
                  </li>
                  <li>
                    <strong>Tokio</strong> is the most common one, but it is
                    <strong>not the only executor</strong> (for example
                    <strong>Embassy</strong> for embedded systems)
                  </li>
                </ul>
              </li>

              <li>
                <strong>Tokio API looks similar to std threads</strong>
                <ul>
                  <li>
                    <code>tokio::spawn(...)</code> vs
                    <code>std::thread::spawn(...)</code>
                  </li>
                  <li>
                    <code>tokio::time::sleep(...)</code> vs
                    <code>std::thread::sleep(...)</code>
                  </li>
                  <li>
                    <strong>‚ö†Ô∏è Warning:</strong> make sure you import the right
                    items (<code>tokio::time</code>, <code>tokio::sync</code>,
                    etc.)
                  </li>
                </ul>
              </li>

              <li>
                <strong>Async is ‚Äúcolored‚Äù</strong>
                <ul>
                  <li>
                    functions must be declared <code>async fn</code> to use
                    <code>.await</code>
                  </li>
                  <li>
                    <code>.await</code> can only be used inside an
                    <code>async</code> function
                  </li>
                </ul>
              </li>

              <li>
                <strong>Futures are lazy</strong>
                <ul>
                  <li>
                    they do nothing until they are <strong>awaited</strong> (or
                    polled by the executor)
                  </li>
                  <li>
                    a spawned task is a <strong>Future</strong> that the runtime
                    will poll
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 ‚Äî Async (cont.)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Task ‚â† thread</strong>
                <ul>
                  <li>
                    a Tokio <strong>task</strong> is a lightweight unit of work
                    managed by the runtime
                  </li>
                  <li>
                    whether it runs on 1 OS thread or many depends on the
                    <strong>executor configuration</strong>
                    (current-thread vs multi-thread runtime)
                  </li>
                  <li>
                    tasks can be moved between worker threads by the runtime
                  </li>
                </ul>
              </li>

              <li>
                <strong>Cooperative concurrency</strong>
                <ul>
                  <li>
                    tasks must <strong>yield</strong> regularly (typically at
                    <code>.await</code> points)
                  </li>
                  <li>
                    the runtime makes progress by polling tasks that are ready
                  </li>
                </ul>
              </li>

              <li>
                <strong>‚ö†Ô∏è Big warning: never block the runtime</strong>
                <ul>
                  <li>
                    blocking a task can freeze <strong>all</strong> tasks on
                    that worker thread (including the TUI loop!)
                  </li>
                  <li>
                    avoid blocking calls inside async code:
                    <code>std::thread::sleep</code>, heavy CPU loops, blocking
                    I/O, etc.
                  </li>
                  <li>
                    if you must run blocking or CPU-bound work:
                    <ul>
                      <li>use <code>tokio::task::spawn_blocking</code></li>
                      <li>
                        it runs on a
                        <strong>dedicated blocking thread pool</strong>
                        and does not block the async runtime
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 - Tokio mpsc</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>mpsc (multi-producer, single-consumer)</strong>
                <ul>
                  <li>
                    tasks communicate by <strong>sending messages</strong>,
                  </li>
                  <li>clear data flow: producer ‚Üí consumer,</li>
                  <li>no shared mutable state.</li>
                </ul>
              </li>

              <li>
                In our case:
                <ul>
                  <li>the <strong>refresh task</strong> sends updates,</li>
                  <li>
                    the <strong>TUI loop</strong> receives and processes them.
                  </li>
                </ul>
              </li>

              <li>
                <strong>Alternative: shared memory</strong>
                <ul>
                  <li>
                    <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or
                    <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>
                  </li>
                  <li>
                    useful when multiple tasks need direct access to the same
                    state
                  </li>
                  <li>requires careful locking and can introduce contention</li>
                </ul>
              </li>

              <li>
                For this workshop, we prefer <strong>channels</strong>:
                <ul>
                  <li>simpler mental model,</li>
                  <li>explicit data flow,</li>
                  <li>well-suited for a TUI event loop.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- =============================================== -->
        <!-- BLOC 3 :  API wrapping and dependency inversion -->
        <!-- =============================================== -->
        <section>
          <h3>Part 3 - API wrapping and dependency inversion</h3>
          <img
            src="images/part03.jpg"
            alt="API wrapping and dependency inversion"
            width="77%"
          />
        </section>

        <section>
          <h3>Part 3 ‚Äî API wrapping</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Goal</strong>: wrap the SNCF API behind a clean and
                minimal interface.
              </li>

              <li>
                We expose only what the application really needs:
                <ul>
                  <li>
                    <code>fetch_places()</code> ‚Äî retrieve and filter places
                    (stop areas),
                  </li>
                  <li>
                    <code>fetch_journeys()</code> ‚Äî retrieve journeys between
                    two places.
                  </li>
                </ul>
              </li>

              <li>
                The rest of the application:
                <ul>
                  <li>does not know about HTTP,</li>
                  <li>does not know about JSON payloads,</li>
                  <li>only works with domain types.</li>
                </ul>
              </li>

              <li>
                This gives us a <strong>clear boundary</strong> between the
                external API and our core logic.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 - Dependency inversion</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Directly calling the HTTP client makes code:
                <ul>
                  <li>hard to test,</li>
                  <li>tightly coupled to the network,</li>
                  <li>dependent on external services.</li>
                </ul>
              </li>

              <li>
                Instead, we invert the dependency:
                <ul>
                  <li>define an <strong>HTTPClient trait</strong>,</li>
                  <li>
                    provide a real implementation (<code>ReqwestClient</code>),
                  </li>
                  <li>
                    provide a fake one (<code>FakeClient</code>) for tests.
                  </li>
                </ul>
              </li>

              <li>
                Benefits:
                <ul>
                  <li>test logic in <strong>isolation</strong>,</li>
                  <li>no network access during tests,</li>
                  <li>deterministic and fast test suite.</li>
                </ul>
              </li>

              <li>
                <strong>Key principle</strong>:
                <ul>
                  <li>
                    The API layer depends on <strong>abstractions</strong>, not
                    on concrete implementations.
                  </li>
                </ul>
              </li>

              <li>
                <strong>Example</strong>:
                <ul>
                  <li>
                    if the SNCF API is no longer HTTP-based (for example
                    <strong>gRPC</strong>),
                    <br />
                    <em>
                      (note: the trait name <code>HTTPClient</code> would no
                      longer be well suited in that case)
                    </em>
                  </li>
                  <li>
                    we only need a <strong>new client implementation</strong>,
                  </li>
                  <li>the rest of the application remains unchanged.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 ‚Äî Data serialization with Serde</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Serde</strong> is the standard framework in Rust for
                <strong>serialization and deserialization</strong>.
                <ul>
                  <li>JSON, YAML, TOML, CSV, and more,</li>
                  <li>fast, type-safe, and widely adopted.</li>
                </ul>
              </li>

              <li>
                Two common deserialization modes:
                <ul>
                  <li>
                    <strong>Typed</strong>: deserialize into user-defined
                    structs (<code>#[derive(Deserialize)]</code>)
                  </li>
                  <li>
                    <strong>Free-form</strong>: deserialize into generic Serde
                    types (e.g. <code>serde_json::Value</code>)
                  </li>
                </ul>
              </li>

              <li>
                <strong>In this workshop</strong>:
                <ul>
                  <li>we mostly use the <strong>typed approach</strong>,</li>
                  <li>
                    to keep domain logic explicit, safe, and easy to test.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 ‚Äî Serde: small example</h3>
          <div class="lots_of_items2">
            <pre><code class="language-rust">
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct Place {
    id: String,
    name: String,
}

// Deserialize JSON into a Rust type
let place: Place = serde_json::from_str(json_str)?;

// Serialize a Rust type back to JSON
let json = serde_json::to_string(&place)?;
    </code></pre>
          </div>
        </section>

        <section>
          <h3>Part 3 - Time handling with jiff</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Dealing with time is hard:
                <ul>
                  <li>time zones,</li>
                  <li>durations,</li>
                  <li>formatting for display.</li>
                </ul>
              </li>

              <li>
                We use <strong>jiff</strong> to build a solid time model:
                <ul>
                  <li>parse zoned datetimes from the API,</li>
                  <li>compute journey durations safely,</li>
                  <li>store time-related data in explicit structures.</li>
                </ul>
              </li>

              <li>
                Alternatives in the Rust ecosystem:
                <ul>
                  <li>
                    <strong>chrono</strong> ‚Äî widely used, feature-rich, mature
                  </li>
                  <li>
                    <strong>time</strong> ‚Äî lower-level, explicit, std-like
                    design
                  </li>
                </ul>
              </li>

              <li>
                Choice here:
                <ul>
                  <li>explicit time zones and strong types,</li>
                  <li>clear semantics for dates and durations,</li>
                  <li>a solid foundation for domain logic and UI.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 ‚Äî HTTP client with reqwest</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>reqwest</strong> is the
                <strong>go-to HTTP client</strong> in the Rust ecosystem
                <ul>
                  <li>widely used and battle-tested,</li>
                  <li>built on top of <code>hyper</code>,</li>
                  <li>well integrated with async Rust.</li>
                </ul>
              </li>

              <li>
                Supports both <strong>async</strong> and
                <strong>blocking</strong> APIs:
                <ul>
                  <li>
                    <code>reqwest::Client</code> ‚Äî async (used in this
                    workshop),
                  </li>
                  <li>
                    <code>reqwest::blocking::Client</code> ‚Äî sync, for simple
                    tools.
                  </li>
                </ul>
              </li>

              <li>
                In our case:
                <ul>
                  <li>
                    used inside the <code>ReqwestClient</code> implementation,
                  </li>
                  <li>configured with a custom <strong>User-Agent</strong>,</li>
                  <li>handles authentication and JSON deserialization.</li>
                </ul>
              </li>

              <li>
                Why it fits well here:
                <ul>
                  <li>non-blocking HTTP calls,</li>
                  <li>works naturally with Tokio,</li>
                  <li>easy to replace thanks to dependency inversion.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 ‚Äî What changed (and how to test)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>What we need to implement</strong>:
                <ul>
                  <li>
                    <code>fetch_journeys()</code> ‚Äî call the API, parse zoned
                    datetimes, compute durations, and map results to the domain
                    model
                  </li>
                  <li>
                    <code>ReqwestClient</code> ‚Äî the real HTTP implementation of
                    the client trait
                  </li>
                </ul>
              </li>

              <li>
                Most of the changes are located in the
                <strong><code>sncf</code> crate</strong>.
                <ul>
                  <li>API wrapping,</li>
                  <li>dependency inversion,</li>
                  <li>time handling and domain mapping.</li>
                </ul>
              </li>

              <li>
                Some tests are marked as <strong>ignored</strong>:
                <ul>
                  <li>they hit the <strong>live SNCF API</strong>,</li>
                  <li>they require network access and a valid API key.</li>
                </ul>
              </li>

              <li>
                To run them:
                <ul>
                  <li>remove the <code>#[ignore]</code> attribute</li>
                </ul>
              </li>

              <li>
                <strong>Note</strong>:
                <ul>
                  <li>
                    the <code>todo!()</code> macro can be used to
                    <strong>temporarily relax the compiler</strong>
                  </li>
                  <li>
                    it allows the code to compile while a part is still missing,
                    until it is properly implemented.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- ======================== -->
        <!-- BLOC 4 :  Config and TUI
        <!-- ======================== -->
        <section>
          <h3>Part 4 - Config and TUI</h3>
          <img src="images/part04.jpg" alt="Config and TUI" width="77%" />
        </section>

        <section>
          <h3>Part 4 ‚Äî Config and TUI</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Goal</strong>: configure the application with
                <strong>start</strong> and
                <strong>destination</strong> stations.
              </li>

              <li>
                Configuration is persisted in
                <strong><code>config.toml</code></strong
                >.
              </li>

              <li>
                Startup logic:
                <ul>
                  <li>
                    <strong>No config file</strong>:
                    <ul>
                      <li>launch the TUI station picker,</li>
                      <li>
                        we cannot start the refresh task yet (stations are
                        unknown),
                      </li>
                      <li>
                        save the selected stations to <code>config.toml</code>.
                      </li>
                    </ul>
                  </li>

                  <li>
                    <strong>Config file exists</strong>:
                    <ul>
                      <li>
                        for now we still show the same screen (simpler flow),
                      </li>
                      <li>but we also start the background refresh task,</li>
                      <li>
                        it should periodically emit messages in the
                        <strong>logs</strong>.
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                This is the first step toward a full TUI dashboard:
                <ul>
                  <li>configuration screen ‚Üí then live data screen.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 ‚Äî Crates: Ratatui & Crossterm</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Ratatui</strong>
                <ul>
                  <li>
                    a Rust library to build rich
                    <strong>terminal user interfaces</strong> (TUIs)
                  </li>
                  <li>
                    widgets: <code>Block</code>, <code>Paragraph</code>,
                    <code>List</code>, <code>Table</code>, etc.
                  </li>
                  <li>
                    layout system to split the screen and render components
                  </li>
                  <li>
                    render loop friendly: draw the UI repeatedly from the
                    current state
                  </li>
                </ul>
              </li>

              <li>
                <strong>Crossterm</strong>
                <ul>
                  <li>cross-platform terminal control and input</li>
                  <li>
                    keyboard events, mouse events (optional), terminal resize
                  </li>
                  <li>
                    enables TUI mode:
                    <ul>
                      <li><strong>raw mode</strong> (no line buffering)</li>
                      <li>
                        <strong>alternate screen</strong> (clean full-screen UI)
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                How they work together:
                <ul>
                  <li>Crossterm handles terminal + events</li>
                  <li>Ratatui renders widgets into a terminal backend</li>
                  <li>
                    we must always <strong>restore</strong> the terminal on exit
                    (even on panic)
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 ‚Äî Raw mode & alternate screen</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Raw mode</strong>
                <ul>
                  <li>disables the terminal‚Äôs default line buffering</li>
                  <li>
                    key presses are sent immediately to the application (no need
                    to press Enter)
                  </li>
                  <li>
                    special keys are exposed as events (<code>Up</code>,
                    <code>Down</code>, <code>Esc</code>, etc.)
                  </li>
                </ul>
              </li>

              <li>
                What changes compared to normal mode:
                <ul>
                  <li>no automatic echo of typed characters</li>
                  <li>no terminal-side editing (backspace, arrows, etc.)</li>
                  <li>
                    the application is fully responsible for input handling
                  </li>
                </ul>
              </li>

              <li>
                <strong>Alternate screen</strong>
                <ul>
                  <li>switches to a separate, temporary screen buffer</li>
                  <li>the original terminal content is preserved</li>
                  <li>
                    on exit, the previous screen is restored automatically
                  </li>
                </ul>
              </li>

              <li>
                Why both are important for TUIs:
                <ul>
                  <li>raw mode enables responsive, interactive input</li>
                  <li>alternate screen provides a clean full-screen UI</li>
                  <li>
                    together, they allow building apps that behave like native
                    tools
                  </li>
                </ul>
              </li>

              <li>
                <strong>Note</strong>:
                <ul>
                  <li>
                    stdout / stderr output (<code>println!</code>,
                    <code>eprintln!</code>) will not work properly anymore,
                  </li>
                  <li>
                    use logging to a file instead (e.g. <code>tracing</code>).
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 ‚Äî Modular TUI structure (MVP)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                The TUI code is split into small modules to stay maintainable:
                <ul>
                  <li>
                    <code>app.rs</code> ‚Äî application state and update logic
                  </li>
                  <li><code>ui.rs</code> ‚Äî rendering (widgets + layout)</li>
                  <li><code>event.rs</code> ‚Äî input/events handling</li>
                </ul>
              </li>

              <li>
                This matches an <strong>MVP-like</strong> architecture:
                <ul>
                  <li>
                    <strong>Model</strong>: app state (<code>app.rs</code>)
                  </li>
                  <li>
                    <strong>View</strong>: terminal UI (<code>ui.rs</code>)
                  </li>
                  <li>
                    <strong>Presenter</strong>: event loop + updates
                    (<code>event.rs</code>)
                  </li>
                </ul>
              </li>

              <li>
                Benefits:
                <ul>
                  <li>clear separation of concerns,</li>
                  <li>easier to test and reason about,</li>
                  <li>UI can evolve without rewriting everything.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>Part 4 ‚Äî Snapshot testing with insta</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>insta</strong> is a snapshot testing library for Rust.
                <ul>
                  <li>captures the output of a function,</li>
                  <li>stores it as a snapshot,</li>
                  <li>compares future runs against it.</li>
                </ul>
              </li>

              <li>
                Why snapshot testing fits TUIs well:
                <ul>
                  <li>TUIs are hard to test with traditional assertions,</li>
                  <li>the rendered output is mostly text-based,</li>
                  <li>snapshots make visual regressions easy to spot.</li>
                </ul>
              </li>

              <li>
                In this project:
                <ul>
                  <li>we snapshot the input screen rendering,</li>
                  <li>without starting a real terminal,</li>
                  <li>by testing the UI logic in isolation.</li>
                </ul>
              </li>

              <li>
                Workflow:
                <ul>
                  <li>run tests ‚Üí snapshot is created or compared,</li>
                  <li>review changes explicitly when the UI evolves,</li>
                  <li>accept updates when they are intentional.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 ‚Äî What to do in this step</h3>
          <div class="lots_of_items2">
            <ul>
              <li>Run the tests with <code>cargo t</code> and fix failures.</li>

              <li>
                But this part includes <strong>a lot of code changes</strong>:
                <ul>
                  <li>
                    the most important goal is to
                    <strong>understand the structure</strong> and
                    <strong>play with the code</strong>
                  </li>
                  <li>
                    don‚Äôt hesitate to explore:
                    <ul>
                      <li>change a widget,</li>
                      <li>tweak navigation,</li>
                      <li>inspect logs and state updates.</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                Please ask questions!
                <ul>
                  <li>
                    if something is unclear, stop and ask ‚Äî we will explain it
                    together
                  </li>
                  <li>
                    the goal is to learn the patterns, not to ‚Äúspeedrun‚Äù the
                    commit
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- =========================== -->
        <!-- BLOC 5 :  TUI and Dashboard
        <!-- =========================== -->
        <section>
          <h3>Part 5 - TUI and Dashboard</h3>
          <img src="images/part05.jpg" alt="TUI and Dashboard" width="37%" />
        </section>

        <section>
          <h3>Part 5 ‚Äî Goal</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Goal</strong>: display a real-time dashboard of journeys
                between the configured <strong>start</strong> and
                <strong>destination</strong> stations.
              </li>

              <li>
                The screen is split into two panels:
                <ul>
                  <li>
                    <strong>Left panel</strong>: journeys list (table)
                    <ul>
                      <li>departure date/time,</li>
                      <li>travel duration,</li>
                      <li>number of transfers / changes.</li>
                    </ul>
                  </li>

                  <li>
                    <strong>Right panel</strong>: countdown timer
                    <ul>
                      <li>
                        time remaining from <strong>now</strong> until the
                        selected departure,
                      </li>
                      <li>big, readable <code>HH:MM:SS</code> display.</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                <strong>Background refresh task</strong>:
                <ul>
                  <li>
                    periodically fetches journeys from the SNCF API (<strong
                      >every 30 seconds</strong
                    >),
                  </li>
                  <li>sends updated data to the dashboard,</li>
                  <li>
                    the UI refreshes automatically based on received data.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 5 ‚Äî tui-big-text (large ASCII rendering)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>tui-big-text</strong> is a small helper crate built on
                top of <strong>Ratatui</strong>.
              </li>

              <li>
                You can think of it as a <strong>plugin-like widget</strong>:
                <ul>
                  <li>it renders text using large ASCII-style characters,</li>
                  <li>designed to be easily embedded in a Ratatui layout.</li>
                </ul>
              </li>

              <li>
                In our dashboard:
                <ul>
                  <li>used to display the countdown timer,</li>
                  <li>
                    large <code>HH:MM:SS</code> format, readable at a glance.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 5 ‚Äî Desktop notifications with notify-rust</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>notify-rust</strong> is a Rust crate to send
                <strong>desktop notifications</strong>.
              </li>

              <li>
                It integrates with the operating system‚Äôs notification system
                (when supported).
              </li>

              <li>
                In our dashboard:
                <ul>
                  <li>
                    when the countdown timer reaches <strong>zero</strong>,
                  </li>
                  <li>a notification is sent to the OS,</li>
                  <li>
                    to alert the user that the departure time has arrived.
                  </li>
                </ul>
              </li>

              <li>
                The notification is sent <strong>only once</strong>:
                <ul>
                  <li>tracked via internal timer state,</li>
                  <li>to avoid spamming the user.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 5 ‚Äî One of the challenges</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                One important challenge in this part is how to
                <strong>manage the HTTP client</strong>.
              </li>

              <li>
                In <strong>Timer mode</strong> (the dashboard):
                <ul>
                  <li>
                    the HTTP client is currently used
                    <strong>only by the background refresh task</strong>,
                  </li>
                  <li>
                    the TUI loop only consumes the refreshed data (it does not
                    call the API directly).
                  </li>
                </ul>
              </li>

              <li>
                This makes one solution tempting:
                <ul>
                  <li>keep the HTTP client entirely inside the task.</li>
                </ul>
              </li>

              <li>
                But we want the design to stay flexible:
                <ul>
                  <li>
                    future features may require HTTP calls from other places
                    (TUI actions, details view, manual refresh, etc.),
                  </li>
                  <li>
                    one possible direction is to make the HTTP client a
                    <strong>property of the application state</strong>
                    (<code>App</code>),
                  </li>
                  <li>so it can be shared when needed, without duplication.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 5 ‚Äî What to do in this step</h3>
          <div class="lots_of_items2">
            <ul>
              <li>Run the tests with <code>cargo t</code> and fix failures.</li>

              <li>
                This part introduces <strong>new behaviors and state</strong>:
                <ul>
                  <li>background data refresh,</li>
                  <li>timer and countdown logic,</li>
                  <li>UI updates driven by incoming data.</li>
                </ul>
              </li>

              <li>
                One part is intentionally a bit tricky:
                <ul>
                  <li>
                    the HTTP client must be used across asynchronous boundaries,
                  </li>
                  <li>and the code needs to compile and remain correct.</li>
                </ul>
              </li>

              <li>
                A suggested approach:
                <ul>
                  <li>
                    first, <strong>make the code compile</strong>, even if it
                    means using multiple client instances,
                  </li>
                  <li>
                    then, step back and think about
                    <strong>a better way to share the client</strong>.
                  </li>
                </ul>
              </li>

              <li>
                Please ask questions!
                <ul>
                  <li>
                    this is a good opportunity to discuss ownership, sharing,
                    and async design choices,
                  </li>
                  <li>
                    the goal is to understand the trade-offs, not just the final
                    solution.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2>Thanks</h2>
          <div class="left_text_top_margin">
            <img src="images/thanks.gif" alt="thank_you" width="100%" />
          </div>
          <div class="right_text">
            <img src="images/qr_feedback.png" alt="feedback" width="85%" />
          </div>
          <ul>
            <li>Cyril Marin &lt;marin.cyril@gmail.com&gt;</li>
            <li>Ren√© Ribaud &lt;rene.ribaud@gmail.com&gt;</li>
          </ul>
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "../reveal.js/dist/reveal.esm.js";
      import Markdown from "../reveal.js/plugin/markdown/markdown.esm.js";
      import Notes from "../reveal.js/plugin/notes/notes.esm.js";
      import Highlight from "../reveal.js/plugin/highlight/highlight.esm.js";
      import Zoom from "../reveal.js/plugin/zoom/zoom.esm.js";

      let deck = new Reveal({
        plugins: [Markdown, Notes, Highlight, Zoom],
        controls: true,
        progress: true,
        history: true,
        center: false,
        width: 960,
        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,
        // Use this to print in pdf
        // margin: 0.6,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,
        maxScale: 1.5,

        transition: "convex",
      });

      deck.initialize();
    </script>
  </body>
</html>
