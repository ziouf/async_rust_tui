<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Async Rust and TUI</title>

    <meta name="description" content="Async Rust and TUI" />
    <meta name="author" content="Cyril Marin" />
    <meta name="author" content="René Ribaud" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />

    <link rel="stylesheet" href="../reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="../reveal.js/dist/theme/beige.css" />
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia"> -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Satisfy"> -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet"> -->

    <!-- Code syntax highlighting -->
    <!-- <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" /> -->
    <link rel="stylesheet" href="css/stackoverflow-light.css" />

    <style type="text/css">
      .iwantitatleft {
        text-align: left;
      }

      .longtext {
        text-align: left;
        font-size: 0.6em;
      }

      /* Larger elements */
      .lots_of_items2 ul {
        font-size: 0.7em;
        text-align: left;
      }

      /* Smaller elements */
      .lots_of_items3 ul {
        font-size: 0.55em;
        text-align: left;
      }

      .lots_of_items3 ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items3 table {
        font-size: 0.8em;
        float: left;
        margin-right: 1em;
      }

      /* Larger elements */
      .lots_of_items4 ul {
        font-size: 0.8em;
        text-align: left;
      }

      /* Normal elements */
      .lots_of_items ul {
        font-size: 0.6em;
        text-align: left;
      }

      .lots_of_items ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items h3 {
        font-size: 0.7em;
      }

      .lots_of_items h4 {
        font-size: 0.6em;
      }

      .lots_of_items code {
        font-size: 0.7em;
      }

      .lots_of_items table {
        float: left;
        margin-right: 1em;
      }

      .clearfix {
        clear: left;
      }

      .long_link a {
        font-size: 0.8em;
      }

      .pic {
        position: relative;
        float: left;
        width: 50%;
        top: 0px;
      }

      /* Remove image margin use in conjuction with .pic */
      .no_margin img {
        margin: 0px;
      }

      .left_text {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
      }

      .left_text_top_margin {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
        margin-top: 66px;
      }

      .left_text_bio {
        position: relative;
        float: left;
        width: 50%;
        font-size: 0.6em;
        text-align: left;
      }

      .right_text {
        width: 50%;
        text-align: left;
        float: right;
        text-align: left;
      }

      .skill-list li {
        font-size: 1.5rem;
        margin-top: 1rem;
      }
      /*
            .reveal a { color: #007DBA; }
            .reveal h2 b { color: #0096D6; }
            .reveal h2 .day { font-size: 0.6em; position:relative; bottom: 20px; }
            .reveal { font-family: "Source Code Pro", "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,sans-serif; font-size:40px; }
            */
      .reveal {
        font-family:
          "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
        font-size: 40px;
      }

      .reveal h2 {
        margin-top: 35px;
      }

      .reveal ul {
        margin: 0 0 0 0;
      }

      .reveal pre {
        width: 100%;
        font-size: 18px;
      }

      .reveal pre code {
        max-height: 100%;
      }

      .reveal section img {
        border: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0);
      }

      body {
        line-height: 1.1;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- <section data-background="images/background.svg" data-background-size="cover"> -->
        <section>
          <h1>Async Rust and TUI</h1>
          <img src="images/snowcamp_logo.png" alt="snowcamp_logo" width="25%" />

          <h2>Snowcamp 2026</h2>
        </section>

        <section>
          <h3>Async Rust and TUI</h3>
          <h3>Welcome and Development Environment Setup</h3>
          <div class="lots_of_items4">
            <ul>
              <li>
                Save time by doing the bevy setup if not already done or as an
                alternative use
                <a href="https://github.com/codespaces"
                  >https://github.com/codespaces</a
                >.
              </li>
              <ol>
                <li>
                  <strong>Install Rust</strong>: rustup, rustc, cargo, clippy,
                  rustfmt.
                </li>
                <li>
                  <strong>Configure Editor</strong>: Set up your preferred
                  editor with Rust Analyzer.
                </li>
                <li>
                  <strong>Clone the workshop repository</strong>
                  from GitHub.<br />
                  <a href="https://github.com/uggla/async_rust_tui"
                    >https://github.com/uggla/async_rust_tui</a
                  >
                </li>
              </ol>
              <li>Then we will do the introduction.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>2 words about us 1/2</h3>
          <div class="left_text_bio">
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: Cyril</li>
                <li>Last name: Marin</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Cloud engineer</li>
                <li>Latest Guild: Mimosa</li>
                <li>Age of Experience: 10+ years</li>
                <li>Preferred weapons: YAML, Shell</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Lone wolf</li>
                <li>Ex-developer but still coder</li>
                <li>
                  The only tuxedo user among a whole team of half bitten apple
                  (Does that make me a rebel undercover?)
                </li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/cyril.png" alt="Cyril" width="53%" />
          </div>
        </section>

        <section>
          <h3>2 words about us 2/2</h3>
          <div class="left_text_bio">
            <!-- <pre class="bio"> -->
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: René (Uggla)</li>
                <li>Last name: Ribaud</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Software engineer</li>
                <li>Previous Class: Solution architect (Cloud / Devops)</li>
                <li>Latest Guild: Red Hat</li>
                <li>Game start: 1998</li>
                <li>Preferred weapons: Rust / Python</li>
                <li>Artefact: Openstack Nova</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Linux and FLOSS since 1995</li>
                <li>Previously Ops, Dev today to produce my bugs</li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/uggla.png" alt="René" width="53%" />
          </div>
        </section>

        <section>
          <h3>Quick Overview of Rust (Optional)</h3>
          <ul>
            <li>
              Provide an alternative to C/C++ and also higher-level languages
            </li>
            <li>
              Multi paradigm language (imperative, functional, object oriented
              (not fully))
            </li>
            <li>Fast, safe, and efficient (modern)</li>
            <li>No garbage collector, ownership and borrow checker</li>
            <li>Dual license MIT and Apache v2.0</li>
            <li>First stable release May 15th, 2015</li>
          </ul>
        </section>

        <section>
          <h3>Common misconception (Optional)</h3>
          <h4>Rust has a hard learning curve</h4>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Yes</strong>: Rust offers many powerful features and
                concepts, which can make the language look difficult at first.
                However, you can write
                <strong>simple and idiomatic Rust</strong> without using
                everything, and learn the language
                <strong>step by step</strong>.
              </li>
              <li>
                But many frustrations come from a different root cause:
                <ul>
                  <li>
                    People <strong>don’t read the book</strong> (at least the
                    key chapters),
                  </li>
                  <li>
                    They try to
                    <strong>transpose habits from other languages</strong>, and
                    quickly hit Rust’s unique concepts (ownership/borrowing,
                    lifetimes, traits…).
                  </li>
                  <li>
                    Developers coming from <strong>C/C++</strong> sometimes feel
                    <strong>limited or constrained by the compiler</strong>.
                  </li>
                  <li>
                    People often
                    <strong>don’t read the compiler error messages</strong>,
                    even though they are usually precise and actionable.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Some of the main difficulties (Optional)</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>1) Immutability</strong></li>
              <ul>
                <li>
                  <strong>Immutable by default</strong> (you opt-in with
                  <code>mut</code>).
                </li>
                <li>
                  Immutable ≠ constant:
                  <ul>
                    <li><strong>const</strong> / compile-time constants</li>
                    <li>
                      <strong>immutable bindings</strong> / runtime values that
                      simply cannot be modified
                    </li>
                  </ul>
                </li>
              </ul>

              <li><strong>2) Ownership</strong> (because there is no GC)</li>
              <ul>
                <li>
                  Goal: <strong>prevent memory errors</strong> (use-after-free,
                  double free, data races).
                </li>
                <li>
                  Core tool: <strong>borrowing</strong> (use references to avoid
                  moving ownership).
                </li>
              </ul>

              <li><strong>3) Type system</strong></li>
              <ul>
                <li>
                  An extremely strict system built on
                  <strong>strong typing</strong>.
                </li>
                <li>
                  It pushes you to make states explicit (enums), model
                  invariants, and handle errors properly.
                </li>
                <li>
                  <strong>No nulls</strong>: there is no <code>null</code>.
                  Instead, Rust encodes absence and errors in the type system:
                  <ul>
                    <li><code>Option&lt;T&gt;</code> for “value or nothing”</li>
                    <li>
                      <code>Result&lt;T, E&gt;</code> for “success or error”
                    </li>
                  </ul>
                  This can feel <strong>confusing at first</strong>, but it
                  forces you to handle all cases explicitly.
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Quick Overview of the project</h3>
          <div class="left_text lots_of_items2">
            <ul>
              <li>
                Goals of the Workshop:
                <ul>
                  <li>To update with screenshot, number of part.</li>
                  <li>30mn parts, tests to validate</li>
                </ul>
              </li>
              <li>
                What we will build together.
                <ul>
                  <li>
                    A TUI dashboard for trains departures between 2 stations
                  </li>
                </ul>
              </li>
            </ul>
          </div>
          <div class="pic lots_of_items">
            <video width="100%" autoplay loop muted>
              <source src="images/asteroids.mp4" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
        </section>

        <section>
          <h3>Quick overview of the session</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Each step starts with <strong>slides</strong>:
                <ul>
                  <li>explanation of the goal,</li>
                  <li>key concepts and points of attention.</li>
                </ul>
              </li>

              <li>
                Then we move to the code:
                <ul>
                  <li>we use <code>cargo test</code> to run the test suite,</li>
                  <li>
                    most of the time, <strong>tests will fail</strong> and you
                    will need to <strong>fix the code</strong>,
                  </li>
                  <li>
                    don’t hesitate to <strong>ask for help</strong> or request
                    additional explanations.
                  </li>
                </ul>
              </li>

              <li>
                Important note:
                <ul>
                  <li>
                    sometimes the code is correct and
                    <strong>the tests need to be fixed instead</strong>.
                  </li>
                </ul>
              </li>

              <li>
                We decide <strong>together</strong> how to proceed:
                <ul>
                  <li>we fix things live if needed,</li>
                  <li>or we move on if the audience feels comfortable.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- ========================== -->
        <!-- BLOC 1 : INTRO & STRUCTURE -->
        <!-- ========================== -->
        <section>
          <h3>Part 1 - Setup and tracing</h3>
          <img src="images/part01.jpg" alt="setup and tracing" width="75%" />
        </section>

        <section>
          <h3>Part 1 — Setup your project correctly</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>Workspace-based project</strong></li>
              <ul>
                <li>
                  The project is organized as a
                  <strong>Cargo workspace</strong>.
                </li>
                <li>
                  It allows us to split responsibilities into multiple crates
                  and
                  <strong>improve compilation times</strong>.
                </li>
              </ul>

              <li><strong>API crate</strong></li>
              <ul>
                <li>
                  A dedicated crate is used to interact with the external API.
                </li>
                <li>
                  Benefits:
                  <ul>
                    <li>clear separation of concerns,</li>
                    <li>reusable logic,</li>
                    <li>faster rebuilds when working on the UI.</li>
                  </ul>
                </li>
              </ul>

              <li><strong>Crate boundaries</strong></li>
              <ul>
                <li><code>lib.rs</code> — public API of a crate</li>
                <li><code>main.rs</code> — binary entry point</li>
                <li>
                  The binary imports and uses the API crate like any external
                  dependency.
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 1 — Setup your project correctly (cont.)</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>Visibility & API design</strong></li>
              <ul>
                <li>Items are <strong>private by default</strong>.</li>
                <li>
                  <code>pub</code> defines what is exposed outside the crate.
                </li>
                <li>
                  Crate boundaries act as a <strong>clear API contract</strong>.
                </li>
              </ul>

              <li><strong>Error handling strategy</strong></li>
              <ul>
                <li>
                  <code>thiserror</code> — structured errors in
                  <strong>libraries</strong>
                </li>
                <li>
                  <code>anyhow</code> — ergonomic error handling in
                  <strong>binaries</strong>
                </li>
                <li>
                  Rule of thumb:
                  <ul>
                    <li><strong>Libraries</strong>: typed, explicit errors</li>
                    <li>
                      <strong>Binaries</strong>: flexible error propagation
                    </li>
                  </ul>
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 1 — Crates</h3>
          <div class="lots_of_items2">
            <ul>
              <li><strong>dotenvy</strong></li>
              <ul>
                <li>
                  Loads environment variables from a <code>.env</code> file.
                </li>
                <li>
                  Useful to keep configuration outside the code (API keys,
                  endpoints, feature flags).
                </li>
              </ul>

              <li><strong>tracing</strong></li>
              <ul>
                <li>
                  The <strong>go-to crate</strong> to instrument Rust
                  applications.
                </li>
                <li>
                  Designed to measure and observe execution:
                  <ul>
                    <li>structured logs,</li>
                    <li>timings and latencies,</li>
                    <li><strong>spans</strong> to follow execution paths.</li>
                  </ul>
                </li>
                <li>
                  Can export data to <strong>OpenTelemetry</strong> for advanced
                  observability.
                </li>
                <li>
                  In this workshop:
                  <ul>
                    <li>
                      we rely on
                      <strong><code>log</code> compatibility</strong>,
                    </li>
                    <li>and write logs to a <strong>file</strong>,</li>
                    <li>
                      which is essential for debugging because
                      <strong
                        >stdout / stderr are not available in TUI mode</strong
                      >.
                    </li>
                  </ul>
                </li>
              </ul>
            </ul>
          </div>
        </section>

        <!-- ======================= -->
        <!-- BLOC 2 : Async and mpsc -->
        <!-- ======================= -->
        <section>
          <h3>Part 2 - Async and mpsc</h3>
          <img src="images/part02.jpg" alt="async and mpsc" width="40%" />
        </section>

        <section>
          <h3>Part 2 — Goals</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                We move to <strong>async</strong> early on:
                <ul>
                  <li>to avoid blocking the future TUI loop,</li>
                  <li>
                    to later perform
                    <strong>real API requests asynchronously</strong>,
                  </li>
                  <li>without changing the overall architecture.</li>
                </ul>
              </li>
              <li>
                For now, the <strong>TUI loop is simulated</strong> inside the
                <code>run()</code> function.
                <ul>
                  <li>
                    It represents the future event loop: rendering, input
                    handling, and state updates.
                  </li>
                </ul>
              </li>

              <li>
                A <strong>background task</strong> simulates periodic data
                updates:
                <ul>
                  <li>it acts like the SNCF API refresh,</li>
                  <li>sends new data at regular intervals,</li>
                  <li>communicates with the TUI loop via a channel.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 — Async</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>You need an executor</strong> to run async code
                <ul>
                  <li>
                    <code>async fn</code> returns a <strong>Future</strong> (it
                    does not run by itself)
                  </li>
                  <li>
                    An executor is responsible for
                    <strong>polling</strong> futures and making progress
                  </li>
                  <li>
                    <strong>Tokio</strong> is the most common one, but it is
                    <strong>not the only executor</strong> (for example
                    <strong>Embassy</strong> for embedded systems)
                  </li>
                </ul>
              </li>

              <li>
                <strong>Tokio API looks similar to std threads</strong>
                <ul>
                  <li>
                    <code>tokio::spawn(...)</code> vs
                    <code>std::thread::spawn(...)</code>
                  </li>
                  <li>
                    <code>tokio::time::sleep(...)</code> vs
                    <code>std::thread::sleep(...)</code>
                  </li>
                  <li>
                    <strong>⚠️ Warning:</strong> make sure you import the right
                    items (<code>tokio::time</code>, <code>tokio::sync</code>,
                    etc.)
                  </li>
                </ul>
              </li>

              <li>
                <strong>Async is “colored”</strong>
                <ul>
                  <li>
                    functions must be declared <code>async fn</code> to use
                    <code>.await</code>
                  </li>
                  <li>
                    <code>.await</code> can only be used inside an
                    <code>async</code> function
                  </li>
                </ul>
              </li>

              <li>
                <strong>Futures are lazy</strong>
                <ul>
                  <li>
                    they do nothing until they are <strong>awaited</strong> (or
                    polled by the executor)
                  </li>
                  <li>
                    a spawned task is a <strong>Future</strong> that the runtime
                    will poll
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 — Async (cont.)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Task ≠ thread</strong>
                <ul>
                  <li>
                    a Tokio <strong>task</strong> is a lightweight unit of work
                    managed by the runtime
                  </li>
                  <li>
                    whether it runs on 1 OS thread or many depends on the
                    <strong>executor configuration</strong>
                    (current-thread vs multi-thread runtime)
                  </li>
                  <li>
                    tasks can be moved between worker threads by the runtime
                  </li>
                </ul>
              </li>

              <li>
                <strong>Cooperative concurrency</strong>
                <ul>
                  <li>
                    tasks must <strong>yield</strong> regularly (typically at
                    <code>.await</code> points)
                  </li>
                  <li>
                    the runtime makes progress by polling tasks that are ready
                  </li>
                </ul>
              </li>

              <li>
                <strong>⚠️ Big warning: never block the runtime</strong>
                <ul>
                  <li>
                    blocking a task can freeze <strong>all</strong> tasks on
                    that worker thread (including the TUI loop!)
                  </li>
                  <li>
                    avoid blocking calls inside async code:
                    <code>std::thread::sleep</code>, heavy CPU loops, blocking
                    I/O, etc.
                  </li>
                  <li>
                    if you must run blocking or CPU-bound work:
                    <ul>
                      <li>use <code>tokio::task::spawn_blocking</code></li>
                      <li>
                        it runs on a
                        <strong>dedicated blocking thread pool</strong>
                        and does not block the async runtime
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 2 - Tokio mpsc</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>mpsc (multi-producer, single-consumer)</strong>
                <ul>
                  <li>
                    tasks communicate by <strong>sending messages</strong>,
                  </li>
                  <li>clear data flow: producer → consumer,</li>
                  <li>no shared mutable state.</li>
                </ul>
              </li>

              <li>
                In our case:
                <ul>
                  <li>the <strong>refresh task</strong> sends updates,</li>
                  <li>
                    the <strong>TUI loop</strong> receives and processes them.
                  </li>
                </ul>
              </li>

              <li>
                <strong>Alternative: shared memory</strong>
                <ul>
                  <li>
                    <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or
                    <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>
                  </li>
                  <li>
                    useful when multiple tasks need direct access to the same
                    state
                  </li>
                  <li>requires careful locking and can introduce contention</li>
                </ul>
              </li>

              <li>
                For this workshop, we prefer <strong>channels</strong>:
                <ul>
                  <li>simpler mental model,</li>
                  <li>explicit data flow,</li>
                  <li>well-suited for a TUI event loop.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- =============================================== -->
        <!-- BLOC 3 :  Api wrapping and dependency inversion -->
        <!-- =============================================== -->
        <section>
          <h3>Part 3 - Api wrapping and dependency inversion</h3>
          <img
            src="images/part03.jpg"
            alt="Api wrapping and dependency inversion"
            width="80%"
          />
        </section>

        <section>
          <h3>Part 3 — API wrapping</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Goal</strong>: wrap the SNCF API behind a clean and
                minimal interface.
              </li>

              <li>
                We expose only what the application really needs:
                <ul>
                  <li>
                    <code>fetch_places()</code> — retrieve and filter places
                    (stop areas),
                  </li>
                  <li>
                    <code>fetch_journeys()</code> — retrieve journeys between
                    two places.
                  </li>
                </ul>
              </li>

              <li>
                The rest of the application:
                <ul>
                  <li>does not know about HTTP,</li>
                  <li>does not know about JSON payloads,</li>
                  <li>only works with domain types.</li>
                </ul>
              </li>

              <li>
                This gives us a <strong>clear boundary</strong> between the
                external API and our core logic.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 - Dependency inversion</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Directly calling the HTTP client makes code:
                <ul>
                  <li>hard to test,</li>
                  <li>tightly coupled to the network,</li>
                  <li>dependent on external services.</li>
                </ul>
              </li>

              <li>
                Instead, we invert the dependency:
                <ul>
                  <li>define an <strong>HTTPClient trait</strong>,</li>
                  <li>
                    provide a real implementation (<code>ReqwestClient</code>),
                  </li>
                  <li>
                    provide a fake one (<code>FakeClient</code>) for tests.
                  </li>
                </ul>
              </li>

              <li>
                Benefits:
                <ul>
                  <li>test logic in <strong>isolation</strong>,</li>
                  <li>no network access during tests,</li>
                  <li>deterministic and fast test suite.</li>
                </ul>
              </li>

              <li>
                <strong>Key principle</strong>:
                <ul>
                  <li>
                    The API layer depends on <strong>abstractions</strong>, not
                    on concrete implementations.
                  </li>
                </ul>
              </li>

              <li>
                <strong>Example</strong>:
                <ul>
                  <li>
                    if the SNCF API is no longer HTTP-based (for example
                    <strong>gRPC</strong>),
                    <br />
                    <em>
                      (note: the trait name <code>HTTPClient</code> would no
                      longer be well suited in that case)
                    </em>
                  </li>
                  <li>
                    we only need a <strong>new client implementation</strong>,
                  </li>
                  <li>the rest of the application remains unchanged.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 — Data serialization with Serde</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Serde</strong> is the standard framework in Rust for
                <strong>serialization and deserialization</strong>.
                <ul>
                  <li>JSON, YAML, TOML, CSV, and more,</li>
                  <li>fast, type-safe, and widely adopted.</li>
                </ul>
              </li>

              <li>
                Two common deserialization modes:
                <ul>
                  <li>
                    <strong>Typed</strong>: deserialize into user-defined
                    structs (<code>#[derive(Deserialize)]</code>)
                  </li>
                  <li>
                    <strong>Free-form</strong>: deserialize into generic Serde
                    types (e.g. <code>serde_json::Value</code>)
                  </li>
                </ul>
              </li>

              <li>
                <strong>In this workshop</strong>:
                <ul>
                  <li>we mostly use the <strong>typed approach</strong>,</li>
                  <li>
                    to keep domain logic explicit, safe, and easy to test.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 — Serde: small example</h3>
          <div class="lots_of_items2">
            <pre><code class="language-rust">
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct Place {
    id: String,
    name: String,
}

// Deserialize JSON into a Rust type
let place: Place = serde_json::from_str(json_str)?;

// Serialize a Rust type back to JSON
let json = serde_json::to_string(&place)?;
    </code></pre>
          </div>
        </section>

        <section>
          <h3>Part 3 - Time handling with jiff</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Dealing with time is hard:
                <ul>
                  <li>time zones,</li>
                  <li>durations,</li>
                  <li>formatting for display.</li>
                </ul>
              </li>

              <li>
                We use <strong>jiff</strong> to build a solid time model:
                <ul>
                  <li>parse zoned datetimes from the API,</li>
                  <li>compute journey durations safely,</li>
                  <li>store time-related data in explicit structures.</li>
                </ul>
              </li>

              <li>
                Alternatives in the Rust ecosystem:
                <ul>
                  <li>
                    <strong>chrono</strong> — widely used, feature-rich, mature
                  </li>
                  <li>
                    <strong>time</strong> — lower-level, explicit, std-like
                    design
                  </li>
                </ul>
              </li>

              <li>
                Choice here:
                <ul>
                  <li>explicit time zones and strong types,</li>
                  <li>clear semantics for dates and durations,</li>
                  <li>a solid foundation for domain logic and UI.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 — HTTP client with reqwest</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>reqwest</strong> is the
                <strong>go-to HTTP client</strong> in the Rust ecosystem
                <ul>
                  <li>widely used and battle-tested,</li>
                  <li>built on top of <code>hyper</code>,</li>
                  <li>well integrated with async Rust.</li>
                </ul>
              </li>

              <li>
                Supports both <strong>async</strong> and
                <strong>blocking</strong> APIs:
                <ul>
                  <li>
                    <code>reqwest::Client</code> — async (used in this
                    workshop),
                  </li>
                  <li>
                    <code>reqwest::blocking::Client</code> — sync, for simple
                    tools.
                  </li>
                </ul>
              </li>

              <li>
                In our case:
                <ul>
                  <li>
                    used inside the <code>ReqwestClient</code> implementation,
                  </li>
                  <li>configured with a custom <strong>User-Agent</strong>,</li>
                  <li>handles authentication and JSON deserialization.</li>
                </ul>
              </li>

              <li>
                Why it fits well here:
                <ul>
                  <li>non-blocking HTTP calls,</li>
                  <li>works naturally with Tokio,</li>
                  <li>easy to replace thanks to dependency inversion.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 3 — What changed (and how to test)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>What we need to implement</strong>:
                <ul>
                  <li>
                    <code>fetch_journeys()</code> — call the API, parse zoned
                    datetimes, compute durations, and map results to the domain
                    model
                  </li>
                  <li>
                    <code>ReqwestClient</code> — the real HTTP implementation of
                    the client trait
                  </li>
                </ul>
              </li>

              <li>
                Most of the changes are located in the
                <strong><code>sncf</code> crate</strong>.
                <ul>
                  <li>API wrapping,</li>
                  <li>dependency inversion,</li>
                  <li>time handling and domain mapping.</li>
                </ul>
              </li>

              <li>
                Some tests are marked as <strong>ignored</strong>:
                <ul>
                  <li>they hit the <strong>live SNCF API</strong>,</li>
                  <li>they require network access and a valid API key.</li>
                </ul>
              </li>

              <li>
                To run them:
                <ul>
                  <li>remove the <code>#[ignore]</code> attribute</li>
                </ul>
              </li>

              <li>
                <strong>Note</strong>:
                <ul>
                  <li>
                    the <code>todo!()</code> macro can be used to
                    <strong>temporarily relax the compiler</strong>
                  </li>
                  <li>
                    it allows the code to compile while a part is still missing,
                    until it is properly implemented.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <!-- ======================== -->
        <!-- BLOC 4 :  Config and TUI
        <!-- ======================== -->
        <section>
          <h3>Part 4 - Config and TUI</h3>
          <img
            src="images/part04.jpg"
            alt="Api wrapping and dependency inversion"
            width="80%"
          />
        </section>

        <section>
          <h3>Part 4 — Config and TUI</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Goal</strong>: configure the application with
                <strong>start</strong> and
                <strong>destination</strong> stations.
              </li>

              <li>
                Configuration is persisted in
                <strong><code>config.toml</code></strong
                >.
              </li>

              <li>
                Startup logic:
                <ul>
                  <li>
                    <strong>No config file</strong>:
                    <ul>
                      <li>launch the TUI station picker,</li>
                      <li>
                        we cannot start the refresh task yet (stations are
                        unknown),
                      </li>
                      <li>
                        save the selected stations to <code>config.toml</code>.
                      </li>
                    </ul>
                  </li>

                  <li>
                    <strong>Config file exists</strong>:
                    <ul>
                      <li>
                        for now we still show the same screen (simpler flow),
                      </li>
                      <li>but we also start the background refresh task,</li>
                      <li>
                        it should periodically emit messages in the
                        <strong>logs</strong>.
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                This is the first step toward a full TUI dashboard:
                <ul>
                  <li>configuration screen → then live data screen.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 — Crates: Ratatui & Crossterm</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Ratatui</strong>
                <ul>
                  <li>
                    a Rust library to build rich
                    <strong>terminal user interfaces</strong> (TUIs)
                  </li>
                  <li>
                    widgets: <code>Block</code>, <code>Paragraph</code>,
                    <code>List</code>, <code>Table</code>, etc.
                  </li>
                  <li>
                    layout system to split the screen and render components
                  </li>
                  <li>
                    render loop friendly: draw the UI repeatedly from the
                    current state
                  </li>
                </ul>
              </li>

              <li>
                <strong>Crossterm</strong>
                <ul>
                  <li>cross-platform terminal control and input</li>
                  <li>
                    keyboard events, mouse events (optional), terminal resize
                  </li>
                  <li>
                    enables TUI mode:
                    <ul>
                      <li><strong>raw mode</strong> (no line buffering)</li>
                      <li>
                        <strong>alternate screen</strong> (clean full-screen UI)
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                How they work together:
                <ul>
                  <li>Crossterm handles terminal + events</li>
                  <li>Ratatui renders widgets into a terminal backend</li>
                  <li>
                    we must always <strong>restore</strong> the terminal on exit
                    (even on panic)
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 — Raw mode & alternate screen</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>Raw mode</strong>
                <ul>
                  <li>disables the terminal’s default line buffering</li>
                  <li>
                    key presses are sent immediately to the application (no need
                    to press Enter)
                  </li>
                  <li>
                    special keys are exposed as events (<code>Up</code>,
                    <code>Down</code>, <code>Esc</code>, etc.)
                  </li>
                </ul>
              </li>

              <li>
                What changes compared to normal mode:
                <ul>
                  <li>no automatic echo of typed characters</li>
                  <li>no terminal-side editing (backspace, arrows, etc.)</li>
                  <li>
                    the application is fully responsible for input handling
                  </li>
                </ul>
              </li>

              <li>
                <strong>Alternate screen</strong>
                <ul>
                  <li>switches to a separate, temporary screen buffer</li>
                  <li>the original terminal content is preserved</li>
                  <li>
                    on exit, the previous screen is restored automatically
                  </li>
                </ul>
              </li>

              <li>
                Why both are important for TUIs:
                <ul>
                  <li>raw mode enables responsive, interactive input</li>
                  <li>alternate screen provides a clean full-screen UI</li>
                  <li>
                    together, they allow building apps that behave like native
                    tools
                  </li>
                </ul>
              </li>

              <li>
                <strong>Note</strong>:
                <ul>
                  <li>
                    stdout / stderr output (<code>println!</code>,
                    <code>eprintln!</code>) will not work properly anymore,
                  </li>
                  <li>
                    use logging to a file instead (e.g. <code>tracing</code>).
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 — Modular TUI structure (MVP)</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                The TUI code is split into small modules to stay maintainable:
                <ul>
                  <li>
                    <code>app.rs</code> — application state and update logic
                  </li>
                  <li><code>ui.rs</code> — rendering (widgets + layout)</li>
                  <li><code>event.rs</code> — input/events handling</li>
                </ul>
              </li>

              <li>
                This matches an <strong>MVP-like</strong> architecture:
                <ul>
                  <li>
                    <strong>Model</strong>: app state (<code>app.rs</code>)
                  </li>
                  <li>
                    <strong>View</strong>: terminal UI (<code>ui.rs</code>)
                  </li>
                  <li>
                    <strong>Presenter</strong>: event loop + updates
                    (<code>event.rs</code>)
                  </li>
                </ul>
              </li>

              <li>
                Benefits:
                <ul>
                  <li>clear separation of concerns,</li>
                  <li>easier to test and reason about,</li>
                  <li>UI can evolve without rewriting everything.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h3>Part 4 — Snapshot testing with insta</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                <strong>insta</strong> is a snapshot testing library for Rust.
                <ul>
                  <li>captures the output of a function,</li>
                  <li>stores it as a snapshot,</li>
                  <li>compares future runs against it.</li>
                </ul>
              </li>

              <li>
                Why snapshot testing fits TUIs well:
                <ul>
                  <li>TUIs are hard to test with traditional assertions,</li>
                  <li>the rendered output is mostly text-based,</li>
                  <li>snapshots make visual regressions easy to spot.</li>
                </ul>
              </li>

              <li>
                In this project:
                <ul>
                  <li>we snapshot the input screen rendering,</li>
                  <li>without starting a real terminal,</li>
                  <li>by testing the UI logic in isolation.</li>
                </ul>
              </li>

              <li>
                Workflow:
                <ul>
                  <li>run tests → snapshot is created or compared,</li>
                  <li>review changes explicitly when the UI evolves,</li>
                  <li>accept updates when they are intentional.</li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Part 4 — What to do in this step</h3>
          <div class="lots_of_items2">
            <ul>
              <li>
                Run the tests with <code>cargo test</code> and fix failures.
              </li>

              <li>
                But this part includes <strong>a lot of code changes</strong>:
                <ul>
                  <li>
                    the most important goal is to
                    <strong>understand the structure</strong> and
                    <strong>play with the code</strong>
                  </li>
                  <li>
                    don’t hesitate to explore:
                    <ul>
                      <li>change a widget,</li>
                      <li>tweak navigation,</li>
                      <li>inspect logs and state updates.</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                Please ask questions!
                <ul>
                  <li>
                    if something is unclear, stop and ask — we will explain it
                    together
                  </li>
                  <li>
                    the goal is to learn the patterns, not to “speedrun” the
                    commit
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2>Thanks</h2>
          <div class="left_text_top_margin">
            <img src="images/thanks.gif" alt="thank_you" width="100%" />
          </div>
          <div class="right_text">
            <img src="images/qr_feedback.png" alt="feedback" width="100%" />
          </div>
          <!-- <ul> -->
          <!--   <li>Bastien Sevajol &lt;bastien@sevajol.fr&gt;</li> -->
          <!--   <li>René Ribaud &lt;rene.ribaud@gmail.com&gt;</li> -->
          <!-- </ul> -->
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "../reveal.js/dist/reveal.esm.js";
      import Markdown from "../reveal.js/plugin/markdown/markdown.esm.js";
      import Notes from "../reveal.js/plugin/notes/notes.esm.js";
      import Highlight from "../reveal.js/plugin/highlight/highlight.esm.js";
      import Zoom from "../reveal.js/plugin/zoom/zoom.esm.js";

      let deck = new Reveal({
        plugins: [Markdown, Notes, Highlight, Zoom],
        controls: true,
        progress: true,
        history: true,
        center: false,
        width: 960,
        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,
        // Use this to print in pdf
        // margin: 0.6,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,
        maxScale: 1.5,

        transition: "convex",
      });

      deck.initialize();
    </script>
  </body>
</html>
